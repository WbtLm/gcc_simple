gcc_simple输出汇编到code.txt
asslan读入code.txt，输出二进制到run.txt
mips_simulator读入run.txt


在前端中，单位是字，int大小为1个unit，其中unit=4。
在mid_code中，单位是1B，int大小为4
在后端中，单位是1B，int大小为4
/*
 低位放在低地址
 栈：空递减
 */
坑：变量名与定义域区分，变量前缀对变量名查询的影响。

前面的开发没有记录开发日志。现在开始记录。
现在：测试了运算符中ret_word.value.block_val都是NULL，
后续：运算产生的所有临时变量记录在block里，填写到ret_word相应位置，在归约为<语句>时将临时变量全部释放。
	在此之前，需要为stack_random添加合并stack的函数，以方便开发。
	归约为语句时，将controller.top() 的block中所有的tmp var释放。done
后续：将symble controller的get_by_name进行改造，自动加block前缀在每个层次中查找（将栈中每个block都试一遍，现在每个block的前缀不正确），将<元素>->[关键字]的制导函数对应修改（现在该制导函数存在错误，认为识别到的关键字一定是在top block中）
后续：在函数void move_val_to_ans(var_node_t vnode_a,string ans_name)中，此函数需重新审阅，要和如下代码段配合
	::var_stack_alloc_begin
	__block_1__var_i 4
	::var_stack_alloc_end
	现阶段，为局部变量分配的寄存器没有释放，也不知道上面的代码段有没有为局部变量申请栈空间。
现在：某函数所有局部变量在进入函数后就分配好了栈空间，
后续：临时变量有问题，如下代码段：
	::var_stack_alloc_begin
	__T_0 4
	::var_stack_alloc_end
	使用的是局部变量的命令，有问题，需要重新梳理。
	另外，move_val_to_ans的功能不明确，ans的含义不明确，需要梳理调用方，之后增加注释

现在：上述问题基本解决完毕，支持指针，解引用（到机器码），但是解引用赋值时没有考虑到内存大于1的情况。
后续：缺少数组，结构体。修改解引用，支持内存大于1的情况(解引用时middle代码需要先声明，后端才能知道需要加载多少内存)。下载mars，
现在：	Q:大于1的内存赋值，中间代码需要提前声明大小，临时变量不能存放在寄存器里了而是直接放在栈中。后端判断若赋值变量大于1，则多次赋值拼凑。这样，后端来说，大于1的内存只支持赋值操作。对与解引用，解引用运算符在中间代码中需要携带size信息。
	先修改后端对指针解引用大于1的支持，然后前端增加结构体功能，
现在：解引用修改完毕（middle携带size信息）。
现在：1+2+。。。+100测试正常。开始写数组。下标运算只允许数组名和普通指针作为左参数，跟c语言有区别。缺少指针+常数的运算。  data_type类中的type_stack顺序应为从前往后解析，可能还存在错误。
后续：除了排错以外，需要完善get_ptr_offset()函数，完成下标运算符。然后检查一下其他运算符对于数据类型的继承和传递，尤其是对解引用、取地址运算的类型传递。
现在：还没完成下标运算符，对于指针解引用作为左值时中间代码解释错误。应该说，编译器对左值的处理欠妥，甚至对i+1=1的表达式都能识别。后面应当在符号表变量(临时变量)属性中增加“左值”或者“地址”这一属性，然后完善“=”运算符对左值的处理。
现在：目前只有 %__MEMORY_OF__ 运算符会牵扯地址左值。故后端只需要针对此运算符进行地址保存操作。目前正在为'+'制导函数增加指针+int的操作，缺少乘法支持，需要跟进。
现在：后端增加乘法支持。memory_of运算符应当调整，左值时不能使用，应当在guid里面调整。
技术：前端保证临时变量只在语句完成后释放、等号运算使用=运算符，其他中间代码保持不变。后端对MEMORY_OF运算符除了取内存值操作以外，为临时变量注册左值{地址变量(运行时确定，临时变量或者正常变量，暂不支持真值)，sizeof}，由于解引用的左值只能在运行时确定，故遇到a memof size时，若a为var，则左值为{a,size}，若a为imm,则左值为{imm,size}。后面、遇到需要左值时优先使用注册的左值{地址变量，sizeof}。删除<=运算符（当然，可以保留用作它用），上述对后端的(左值优先性)修改只需要修改无参数的=运算符(ans = val)。

现在：指针开发完毕但是有bug。前端生成的中间代码临时变量声明不全（初步认定是程序块造成block丢失）。mips模拟器里访问0内存。后续要debug。  循环中对临时变量的释放，在back_var_ctrl中已经将索引删掉了。但是还bug。继续调试吧

现在：临时变量声明不全问题：临时变量的声明不再维护，后期会删去。因为临时变量不会跨越语句，故现在的语句后释放策略不会造成运行时的循环因为临时变量的释放产生错误。【缺陷】指针左值的冗余处理方式要求：对使用语句*p对内存的访问，内存如果要有写权限，就必须得拥有读权限。因为写之前都会读一次（无用功）。
hint:运行时循环不会造成当前寄存器、内存释放策略的资源非法访问。解决方案：将if和goto分离，中间允许free
现在：中间代码中goto跳转语句可能会打断 运行时类型资源的释放。如栈中临时变量的释放。注意：要始终保证栈顶指针指向栈顶，否则会遇到bug。 
hint:要保证中间代码中if的判断条件为int。现在效果为如果条件大于四个字节，只判断第一个32位。(编译前端保证，待解决)
现在：指针已经搞定了，上面的bug也解决了，暂时稳定。
后续：完成数组
发现：address_of运算符存在bug：修改方案为：对于memory_of运算符生成的存在特殊左值的临时变量取地址时需要取其特殊左值而不是耿直地取临时变量的地址。范例：&*p;
论文：文法中特意将内容分成两个部分，如while分为头部和尾部，如结构体分为结构体头部=和结构体尾部。是一个特殊技巧。如结构体的拆分可以允许头部为符号表写入信息，供尾部使用。
现在：全局数组没有生效，局部数组名没有变为常量，
现在：完成数组，解决了address of的左值bug。
后续：开始写struct，首先要把[数据类型]变为<广义数据类型>，修改文法、制导函数。修改struct定义，拆出struct头部。然后使用指针指向结构头部的形式完成编译前端。后端不用修改。
现在：修改了文法计算acc的goto未初始化的bug。
现在：结构体的类型类写完了，结构体定义的guid写完了，点运算符写完了。还差前端的内存分配（主要是预留出一个ptr的空间），后端的大内存复制cr。
现在：find_matrix函数中find_R_left()函数可能有bug
现在：修改完毕语法分析的bug
现在技术：前端结构体处理时。栈内结构体由于编译后端取address——of时对地址有倒立操作。故前端不需要额外移动一个unit。这里有一种前端依赖后端的味道。但是不是强依赖，可认为是一种约定（是个不合理的约定罢了）。
现在：struct多余一个this指针的实现方式有bug：用户使用malloc或者其他方式申请空间时，this指针无法被正确初始化。故，重写struct实现方法，改为使用address of运算符取地址，生成临时指针的方式。
技术：运算符的文法使用的左递归，故计算优先从左到右。所以在使用连等（a=b=c）时，优先结合a=b，然后结果为a,然后a=c
bug:对struct地址计算法中，memory of的操作有漏洞：如：T3=T2 MEMORY OF 4; T3 = 101 ; T1=T3;中，给T3赋值为101后，T1=T3无法正确得取得101这个刚刚赋予的右值。这个问题的实质，是memory of运算符的结果T3只能使用一次（不论是当左值还是右值）。分析：造成bug的本质，也就是只能用一次的实质为：为T3赋值为优先给T3的左值赋值，但是没有同步给T3的右值。故有两种解决方案：1.给左值赋值的同时，将值同步给右值。2.在取右值的时候，若其存在左值，则从左值中取数据而不是取右值。第二种方案可以解决memory of 的冗余代码和冗余权限的问题。但是工程量巨大，需要对每一处使用右值的地方进行左值判断。故采用方案1,又由于该问题只存在于左右值同时存在的情况，所以只需修改纯赋值运算符即可。
现在：后端符号表对栈内pos指向的是顶端。跟实际相反非常不方便，但是各个地方都已经做好了转换就这样写着吧。
bug：数组大于unit的偏移计算错误
现在：结构体和数组基本完毕，开始写函数参数
现在：计划的函数参数只允许一个int类型，现在文法基本完毕。但是函数声明无法告知code block参数是什么。故后面还需要为函数声明再套一个产生式，在新产生式中使用全局变量记录下参数名字。在code block中进行全局变量的判断。
技术：前端只进行::set_arg，具体参数的释放由后端进行。
现在：if没有实现，break、continue没有实现。正在写if

潜在的bug：不知道支持不支持负数（主要是比较运算符之类的），还没有减法没法验证
现在：负数可能有bug。if-else写完并调试完毕，修改了return语句可能造成的资源未释放的bug（主要是造成编译前端中间代码生成错误，和造成栈空间不能来得及释放，使栈指针不平衡的严重后果）。后面完成continue和break语句，开始写减法，排出上面的bug
现在：continue、break搞定。（注意所有跳转都需要考虑资源释放的问题）
注意：由于hi和lo可能会被中断等打断，所以在中断处理函数等地方要保存hi和lo的现场。
新增：新增==、-、continue、break、if-else
语法不同：&&和||运算符不会因为前面条件的成立而停止后面的运算。因为编译器实现是用的数值运算，并没有用条件跳转。
技术：如何给bool值取反？可以用1减去这个logic实现：1-1=0,1-0=1;
注意：a||b != bool(a+b)，因为可能存在：a=-b且a!=0的情况。
